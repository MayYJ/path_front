package com.may.routeplansystem.service.impl;import com.github.pagehelper.PageHelper;import com.may.routeplansystem.constant.ProcessState;import com.may.routeplansystem.dao.DistanceDao;import com.may.routeplansystem.dao.NodeDao;import com.may.routeplansystem.dao.QuestionDao;import com.may.routeplansystem.entity.dto.ResponseEntity;import com.may.routeplansystem.entity.po.Distance;import com.may.routeplansystem.entity.po.NodePojo;import com.may.routeplansystem.entity.po.Question;import com.may.routeplansystem.exception.ParameterException;import com.may.routeplansystem.exception.ProcessException;import com.may.routeplansystem.exception.ServerException;import com.may.routeplansystem.node_excel_check.NodeExcelCheck;import com.may.routeplansystem.node_excel_read.NodeExcelRead;import com.may.routeplansystem.service.DistanceService;import com.may.routeplansystem.service.NodeService;import com.may.routeplansystem.service.util.ServiceUtil;import com.may.routeplansystem.util.BiTupple;import lombok.extern.slf4j.Slf4j;import org.apache.poi.ss.usermodel.Workbook;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.beans.factory.annotation.Value;import org.springframework.context.ApplicationContext;import org.springframework.stereotype.Service;import org.springframework.transaction.annotation.Transactional;import org.springframework.web.multipart.MultipartFile;import javax.annotation.Resource;import javax.servlet.http.HttpServletRequest;import java.util.ArrayList;import java.util.List;import java.util.Objects;/** * @author:dengsiyuan * @Date:2018/10/22 16:28 */@Service@Slf4jpublic class NodeServiceImpl implements NodeService {    private Logger logger = LoggerFactory.getLogger(this.getClass());    @Resource    private NodeDao nodeDao;    @Resource    private BatchImportService batchImportService;    @Resource    private DistanceDao distanceDao;    @Resource    private QuestionDao questionDao;    @Resource    private DistanceService distanceService;    @Resource    private ApplicationContext applicationContext;    @Value("${excel.node_read}")    private String nodeReadVersion;    @Value("${excel.node_check}")    private String nodeCheckVersion;    @Override    public ResponseEntity nodeBatchImport(MultipartFile file, HttpServletRequest request, int questionId) {        return batchImportService.batchImport(file, request, questionId, this::readExcelToDatabase);    }    @Transactional(rollbackFor = ServerException.class)    ResponseEntity readExcelToDatabase(Workbook wb, int questionId) {        checkExcel(wb);        NodeExcelRead nodeExcelRead = (NodeExcelRead) applicationContext.getAutowireCapableBeanFactory()                .getBean(this.nodeReadVersion);        BiTupple<ResponseEntity, List<NodePojo>> tupple = nodeExcelRead.read(wb, questionId);        ResponseEntity responseEntity = tupple.getT();        List<NodePojo> nodes = tupple.getU();        for (int i = 0; i < nodes.size(); i++) {            boolean insertFlag = nodeDao.insertNode(nodes.get(i));            if (!insertFlag) {                responseEntity.setStatus(5);                responseEntity.setMsg( "服务器错误, 请下次从第" + i+1 + "行数据开始导入" );                return responseEntity;            }        }        updateStateFlagOrNot(questionId);        return responseEntity;    }    private void updateStateFlagOrNot(int questionId) {        Question question = questionDao.findQuestionByQuestionId(questionId);        if (question == null) {            throw new ProcessException("请先创建问题");        }        if (question.getProcessState() < ProcessState.LOAD_NODE){            questionDao.updateQuestionProcessState(ProcessState.LOAD_NODE, questionId);        }    }    private void checkExcel(Workbook workbook) {        NodeExcelCheck nodeExcelCheck= (NodeExcelCheck) applicationContext.getAutowireCapableBeanFactory()                .getBean(this.nodeCheckVersion);        nodeExcelCheck.check(workbook);    }    @Override    @Transactional(rollbackFor = Exception.class)    public void insertNode(NodePojo nodePojo) {        Question question = questionDao.findQuestionByQuestionId(nodePojo.getQuestionId());        checkState(question, "正在准备数据，不能添加点数据");        int questionId = nodePojo.getQuestionId();        questioCheck(questionId);        boolean flag = nodeDao.insertNode(nodePojo);        int processState = question.getProcessState();        if (processState < ProcessState.LOAD_NODE) {            questionDao.updateQuestionProcessState(ProcessState.LOAD_NODE, questionId);        }        ServiceUtil.checkSqlExecuted(flag);        updateDistanceOrNotForInsertOne(nodePojo, processState);    }    @Override    @Transactional(rollbackFor = Exception.class)    public void insertNodeBatch(List<NodePojo> nodes) {        if (nodes.isEmpty()) {            return;        }        int questionId = nodes.get(0).getQuestionId();        Question question = questionDao.findQuestionByQuestionId(questionId);        checkState(question, "正在准备数据，不能添加点数据");        questioCheck(questionId);        nodeDao.insertNodeBatch(nodes);        int processState = question.getProcessState();        if (processState < ProcessState.LOAD_NODE) {            questionDao.updateQuestionProcessState(ProcessState.LOAD_NODE, questionId);        }        updateDistanceOrNotForInsertBatch(nodes, questionId, processState);    }    private void updateDistanceOrNotForInsertBatch(List<NodePojo> nodes, int questionId,                                                   int processState) {        if (processState == ProcessState.COMPLETE_DISTANCE_PREPARE) {            List<NodePojo> nodesInserted = nodeDao.selectAllNodes(questionId);            List<NodePojo> mergeNodes = new ArrayList<>(nodes.size() + nodesInserted.size());            mergeNodes.addAll(nodes);            mergeNodes.addAll(nodesInserted);            nodes.stream().parallel().forEach(node -> mergeNodes.stream()                    .forEach(mergeNode -> {                        if (! node.getNodeId().equals(mergeNode.getNodeId())) {                            generateDistance(node, mergeNode);                        }                    }));        }    }    private void updateDistanceOrNotForInsertOne(NodePojo node, int processState) {        int quesitonId = node.getQuestionId();        if (processState == ProcessState.COMPLETE_DISTANCE_PREPARE) {            List<NodePojo> nodes = nodeDao.selectAllNodes(quesitonId);            if (nodes.isEmpty()) {                return;            }            nodes.stream().parallel().forEach(nodePojo -> {                if (!node.getNodeId().equals(nodePojo.getNodeId()) ) {                    generateDistance(node, nodePojo);                }            });        }    }    private void generateDistance(NodePojo node1, NodePojo node2) {        int questionId = node1.getQuestionId();        Distance distance = new Distance();        distance.setStartNodeId(node1.getNodeId());        distance.setEndNodeId(node2.getNodeId());        distance.setQuestionId(questionId);        distanceService.getDistanceTimeAndDisAndInsert(distance);        Distance distance1 = new Distance();        distance1.setStartNodeId(node2.getNodeId());        distance1.setEndNodeId(node1.getNodeId());        distance1.setQuestionId(questionId);        distanceService.getDistanceTimeAndDisAndInsert(distance1);    }    private void questioCheck(int questionId) {        Question question = questionDao.findQuestionByQuestionId(questionId);        if (question == null) {            throw new ProcessException("没有该id的问题");        }    }    @Override    @Transactional(rollbackFor = Exception.class)    public void deleteNodeByQuestionId(Integer questionId) {        if (questionId == null) {            return;        }        Question question = questionDao.findQuestionByQuestionId(questionId);        checkState(question, "正在准备数据，不能删除点数据, 您可以先停止准备数据");        nodeDao.deleteNodeByQuestionId(questionId);        distanceDao.removeDistanceByQuestionId(questionId);    }    @Override    @Transactional(rollbackFor = Exception.class)    public void deleteNodeByNodeId(Integer questionId, Integer nodeId) {        if (questionId == null && nodeId == null) {            return;        }        if (nodeId != null && questionId == null) {            throw new ParameterException("删除点数据必须指定questionId");        }        Question question = questionDao.findQuestionByQuestionId(questionId);        checkState(question, "正在准备数据，不能删除点数据, 您可以先停止准备数据");        nodeDao.deleteNodeByNodeId(nodeId);        updateDistanceOrNotForDelete(nodeId, questionId);    }    private void updateDistanceOrNotForDelete(int nodeId, int questionId) {        Question question = questionDao.findQuestionByQuestionId(questionId);        if (question.getProcessState() == ProcessState.COMPLETE_DISTANCE_PREPARE) {            List<NodePojo> nodes = nodeDao.selectAllNodes(questionId);            nodes.stream().parallel().forEach(node -> {                if (nodeId == node.getNodeId()) {                    Distance distance = new Distance();                    distance.setStartNodeId(node.getNodeId());                    distance.setEndNodeId(nodeId);                    Distance distance1 = new Distance();                    distance.setStartNodeId(nodeId);                    distance.setEndNodeId(node.getNodeId());                    ServiceUtil.checkSqlExecuted(distanceDao.removeDistanceByStartNodeIdAndEndNodeId(distance)                    && distanceDao.removeDistanceByStartNodeIdAndEndNodeId(distance1));                }            });        }    }    private void checkState(Question question, String msg) {        if (question == null) {            throw new ParameterException("没有该Id的问题");        }        int processState = question.getProcessState();        if (processState == ProcessState.CALCULATING_DISTANCE) {            throw new ProcessException(msg);        }        if (processState == ProcessState.PROCESSING_SIMPLE                || processState == ProcessState.PROCESSING_GENETIC) {            throw new ProcessException("有算法正在执行，不能添加或者删除基本数据");        }    }    @Override    public void updateNode(NodePojo nodePojo) {        Objects.requireNonNull(nodePojo, "服务点或者中心点数据为空");        boolean flag = nodeDao.updateNodeByNodeId(nodePojo);        ServiceUtil.checkSqlExecuted(flag);    }    @Override    public List<NodePojo> getQuestionNodes(int questionId) {        List<NodePojo> nodes = nodeDao.selectAllNodes(questionId);        return nodes;    }}